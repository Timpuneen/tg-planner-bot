import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.date import DateTrigger
from apscheduler.triggers.cron import CronTrigger
from datetime import datetime, time, timedelta
import calendar
import pytz
import logging

from services.timezone_service import convert_user_time_to_scheduler_timezone, get_scheduler_timezone
from database.connection import db
from services.openai_service import generate_daily_motivation
from services.encryption_service import decrypt_text  # –ù–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç
from aiogram import types

logger = logging.getLogger(__name__)


def is_last_day_of_month(date: datetime) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –¥–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–º –¥–Ω—ë–º –º–µ—Å—è—Ü–∞"""
    last_day = calendar.monthrange(date.year, date.month)[1]
    return date.day == last_day


def parse_cron_expression(cron_expr: str, timezone) -> CronTrigger | None:
    """
    –ü–∞—Ä—Å–∏—Ç cron-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Trigger.
    –ü–æ–¥–¥–µ—Ä–∂–∫–∞ L (–ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞).
    """
    parts = cron_expr.split()
    if len(parts) != 5:
        raise ValueError(f"Invalid cron expression: {cron_expr}")

    minute, hour, day, month, day_of_week = parts

    # –ï—Å–ª–∏ –µ—Å—Ç—å L –≤ –ø–æ–ª–µ day ‚Üí –¥–µ–ª–∞–µ–º CronTrigger –Ω–∞ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
    if day == "L":
        return CronTrigger(
            minute=minute,
            hour=hour,
            day="*",
            month=month,
            day_of_week=day_of_week,
            timezone=timezone
        )
    else:
        return CronTrigger(
            minute=minute,
            hour=hour,
            day=day,
            month=month,
            day_of_week=day_of_week,
            timezone=timezone
        )


class SchedulerService:
    def __init__(self, bot):
        self.scheduler = AsyncIOScheduler(timezone=pytz.UTC)
        self.bot = bot

    async def start(self):
        """–ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
        self.scheduler.start()
        logger.info("Scheduler started")

        await self.load_active_reminders()
        await self.setup_system_tasks()

    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
        self.scheduler.shutdown(wait=False)
        logger.info("Scheduler stopped")

    async def load_active_reminders(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π"""
        try:
            async with db.pool.acquire() as conn:
                once_reminders = await conn.fetch(
                    """SELECT r.reminder_id, r.user_id, r.text, r.trigger_time, u.timezone
                       FROM reminders r
                       JOIN users u ON r.user_id = u.user_id
                       WHERE r.reminder_type = 'once' AND r.is_active = TRUE 
                       AND r.trigger_time > NOW()"""
                )

                for reminder in once_reminders:
                    # –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
                    try:
                        decrypted_text = decrypt_text(reminder['text'])
                    except Exception as e:
                        logger.error(f"Failed to decrypt reminder {reminder['reminder_id']}: {e}")
                        decrypted_text = "[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]"

                    scheduler_time = convert_user_time_to_scheduler_timezone(
                        reminder['trigger_time'],
                        reminder['timezone'],
                        get_scheduler_timezone()
                    )

                    await self.add_once_reminder(
                        reminder['reminder_id'],
                        reminder['user_id'],
                        decrypted_text,
                        scheduler_time
                    )

                recurring_reminders = await conn.fetch(
                    """SELECT r.reminder_id, r.user_id, r.text, r.cron_expression, u.timezone
                       FROM reminders r
                       JOIN users u ON r.user_id = u.user_id
                       WHERE r.reminder_type = 'recurring' AND r.is_active = TRUE"""
                )

                for reminder in recurring_reminders:
                    # –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
                    try:
                        decrypted_text = decrypt_text(reminder['text'])
                    except Exception as e:
                        logger.error(f"Failed to decrypt reminder {reminder['reminder_id']}: {e}")
                        decrypted_text = "[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]"

                    await self.add_recurring_reminder_with_timezone(
                        reminder['reminder_id'],
                        reminder['user_id'],
                        decrypted_text,
                        reminder['cron_expression'],
                        reminder['timezone']
                    )

            logger.info(f"Loaded {len(once_reminders)} once and {len(recurring_reminders)} recurring reminders")

        except Exception as e:
            logger.error(f"Error loading active reminders: {e}")

    async def add_recurring_reminder_with_timezone(self, reminder_id: int, user_id: int,
                                                   text: str, cron_expression: str, user_timezone: str):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Å —É—á–µ—Ç–æ–º —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞"""
        try:
            job_id = f"reminder_recurring_{reminder_id}"
            user_tz = pytz.timezone(user_timezone)

            trigger = parse_cron_expression(cron_expression, user_tz)

            self.scheduler.add_job(
                self._wrapped_send_recurring_reminder,
                trigger=trigger,
                args=[user_id, text, reminder_id, cron_expression],
                id=job_id,
                replace_existing=True
            )

            logger.info(f"Added recurring reminder {reminder_id} for user {user_id} in timezone {user_timezone}")

        except Exception as e:
            logger.error(f"Error adding recurring reminder with timezone: {e}")

    def _get_reminder_message_by_priority(self, user_timezone: str) -> tuple[str, str]:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É: –≥–æ–¥ > –º–µ—Å—è—Ü > –Ω–µ–¥–µ–ª—è > –¥–µ–Ω—å
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—Ç–∏–ø_–ø–µ—Ä–∏–æ–¥–∞, —Ç–µ–∫—Å—Ç_—Å–æ–æ–±—â–µ–Ω–∏—è)
        """
        from services.timezone_service import get_user_time
        
        current_time = get_user_time(user_timezone)
        today = current_time.date()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ–¥ (31 –¥–µ–∫–∞–±—Ä—è)
        if today.month == 12 and today.day == 31:
            return "–≥–æ–¥", "üéä –ì–æ–¥ –ø–æ–¥—Ö–æ–¥–∏—Ç –∫ –∫–æ–Ω—Ü—É! –í—Ä–µ–º—è –ø–æ–¥–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥–∏ –≥–æ–¥–∞ –∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ü–µ–ª–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –≥–æ–¥.\n\n–û—Ç–º–µ—Ç—å—Ç–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –≥–æ–¥–∞ –∏ —Å–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ!"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Å—è—Ü (–ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞)
        if is_last_day_of_month(current_time):
            return "–º–µ—Å—è—Ü", "üìÖ –ú–µ—Å—è—Ü –ø–æ–¥—Ö–æ–¥–∏—Ç –∫ –∫–æ–Ω—Ü—É! –í—Ä–µ–º—è –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –º–µ—Å—è—Ü–∞.\n\n–û—Ç–º–µ—Ç—å—Ç–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –º–µ—Å—è—Ü–∞ –∏ —Å–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ!"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–¥–µ–ª—é (–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)
        if today.weekday() == 6:  # 6 = –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ
            return "–Ω–µ–¥–µ–ª—è", "üìä –ù–µ–¥–µ–ª—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è! –û—Ç–ª–∏—á–Ω–æ–µ –≤—Ä–µ–º—è –ø–æ–¥–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥–∏ –Ω–µ–¥–µ–ª–∏.\n\n–û—Ç–º–µ—Ç—å—Ç–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –Ω–µ–¥–µ–ª–∏ –∏ —Å–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ!"
        
        # –û–±—ã—á–Ω—ã–π –¥–µ–Ω—å
        return "–¥–µ–Ω—å", "üåÖ –î–µ–Ω—å –ø–æ–¥—Ö–æ–¥–∏—Ç –∫ –∫–æ–Ω—Ü—É! –í—Ä–µ–º—è –ø–æ–¥–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥–∏ –¥–Ω—è.\n\n–û—Ç–º–µ—Ç—å—Ç–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –¥–Ω—è –∏ —Å–æ—Å—Ç–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ!"

    async def _wrapped_send_recurring_reminder(self, user_id: int, text: str, reminder_id: int, cron_expression: str):
        """
        –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.
        –¢–µ–ø–µ—Ä—å –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É.
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            async with db.pool.acquire() as conn:
                user = await conn.fetchrow("SELECT timezone FROM users WHERE user_id = $1", user_id)
                
            if not user:
                logger.error(f"User {user_id} not found")
                return
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º —É–º–Ω—ã–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º
            async with db.pool.acquire() as conn:
                reminder = await conn.fetchrow(
                    "SELECT is_built_in FROM reminders WHERE reminder_id = $1", 
                    reminder_id
                )
            
            if reminder and reminder['is_built_in']:
                # –î–ª—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
                period_type, smart_message = self._get_reminder_message_by_priority(user['timezone'])
                await self.send_reminder(user_id, smart_message, reminder_id, 'recurring')
                logger.info(f"Sent smart {period_type} reminder to user {user_id}")
            else:
                # –î–ª—è –æ–±—ã—á–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π —Å L –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞
                if "L" in cron_expression:
                    from services.timezone_service import get_user_time
                    current_time = get_user_time(user['timezone'])
                    if not is_last_day_of_month(current_time):
                        return  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞
                
                await self.send_reminder(user_id, text, reminder_id, 'recurring')
                
        except Exception as e:
            logger.error(f"Error in wrapped recurring reminder {reminder_id}: {e}")

    async def add_once_reminder(self, reminder_id: int, user_id: int, text: str, trigger_time: datetime):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–æ–≤–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"""
        try:
            job_id = f"reminder_once_{reminder_id}"
            scheduler_tz = pytz.timezone(get_scheduler_timezone())
            aware_trigger_time = scheduler_tz.localize(trigger_time)

            self.scheduler.add_job(
                self.send_reminder,
                trigger=DateTrigger(run_date=aware_trigger_time),
                args=[user_id, text, reminder_id, 'once'],
                id=job_id,
                replace_existing=True
            )

            logger.info(f"Added once reminder {reminder_id} for user {user_id} at {aware_trigger_time}")

        except Exception as e:
            logger.error(f"Error adding once reminder: {e}")

    async def remove_reminder(self, reminder_id: int, reminder_type: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"""
        try:
            job_id = f"reminder_{reminder_type}_{reminder_id}"
            if self.scheduler.get_job(job_id):
                self.scheduler.remove_job(job_id)
                logger.info(f"Removed {reminder_type} reminder {reminder_id}")

        except Exception as e:
            logger.error(f"Error removing reminder: {e}")

    async def send_reminder(self, user_id: int, text: str, reminder_id: int, reminder_type: str):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        try:
            message = f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ:\n\n{text}"
            await self.bot.send_message(user_id, message)

            if reminder_type == 'once':
                async with db.pool.acquire() as conn:
                    await conn.execute(
                        "DELETE FROM reminders WHERE reminder_id = $1",
                        reminder_id
                    )
                logger.info(f"Deleted once reminder {reminder_id}")

        except Exception as e:
            logger.error(f"Error sending reminder: {e}")

    async def setup_system_tasks(self):
        """–°–∏—Å—Ç–µ–º–Ω—ã–µ –∑–∞–¥–∞—á–∏"""
        try:
            self.scheduler.add_job(
                self.send_daily_motivation,
                trigger=CronTrigger(hour=8, minute=0),
                id="daily_motivation",
                replace_existing=True
            )

            self.scheduler.add_job(
                self.send_evening_review,
                trigger=CronTrigger(hour=23, minute=0),
                id="evening_review",
                replace_existing=True
            )

            self.scheduler.add_job(
                self.check_overdue_tasks,
                trigger=CronTrigger(hour=0, minute=30),
                id="overdue_check",
                replace_existing=True
            )

            logger.info("System tasks setup completed")

        except Exception as e:
            logger.error(f"Error setting up system tasks: {e}")

    async def send_daily_motivation(self):
        """–£—Ç—Ä–µ–Ω–Ω–∏–µ –º–æ—Ç–∏–≤–∞—Ü–∏–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ –∫–Ω–æ–ø–æ–∫)"""
        try:
            async with db.pool.acquire() as conn:
                users = await conn.fetch("SELECT user_id FROM users")

            motivation = await generate_daily_motivation()
            message = f"üåÖ –î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!\n\n{motivation}"

            for user in users:
                try:
                    await self.bot.send_message(user['user_id'], message)
                except Exception as e:
                    logger.error(f"Error sending morning message to user {user['user_id']}: {e}")

        except Exception as e:
            logger.error(f"Error sending daily motivation: {e}")

    async def send_evening_review(self):
        """–í–µ—á–µ—Ä–Ω–∏–µ —Ä–µ–≤—å—é —Å –∑–∞–ø–∏—Å—è–º–∏ –¥–Ω–µ–≤–Ω–∏–∫–∞ –∏ –∑–∞–¥–∞—á–∞–º–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"""
        try:
            async with db.pool.acquire() as conn:
                users = await conn.fetch("SELECT user_id, timezone FROM users")

            for user in users:
                try:
                    await self.send_user_evening_review(user['user_id'])
                except Exception as e:
                    logger.error(f"Error sending evening review to user {user['user_id']}: {e}")

        except Exception as e:
            logger.error(f"Error in send_evening_review: {e}")

    async def send_user_evening_review(self, user_id: int):
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–≤—å—é –¥–Ω—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π –¥–∞–Ω–Ω—ã—Ö"""
        try:
            async with db.pool.acquire() as conn:
                user = await conn.fetchrow("SELECT timezone FROM users WHERE user_id = $1", user_id)
                if not user:
                    logger.error(f"User {user_id} not found")
                    return

            from services.timezone_service import get_user_time
            current_time = get_user_time(user['timezone'])
            today = current_time.date()
            yesterday = today - timedelta(days=1)
            
            today_utc_start, today_utc_end = self._get_day_utc_bounds(today, user['timezone'])
            yesterday_utc_start, yesterday_utc_end = self._get_day_utc_bounds(yesterday, user['timezone'])

            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å–∏ –¥–Ω–µ–≤–Ω–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ)
            async with db.pool.acquire() as conn:
                diary_entries = await conn.fetch(
                    """SELECT content, created_at FROM diary_entries 
                       WHERE user_id = $1 AND entry_date = $2
                       ORDER BY created_at ASC""",
                    user_id, today
                )

                # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ –¥–ª—è —Ä–µ–≤—å—é (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ)
                review_tasks = await conn.fetch(
                    """SELECT text, category, status, deadline, completed_at FROM tasks 
                       WHERE user_id = $1 AND (
                           -- –ó–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–µ–≥–æ–¥–Ω—è
                           (status = 'completed' AND completed_at >= $2 AND completed_at <= $3)
                           OR
                           -- –ó–∞–¥–∞—á–∏ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∫–∞–∫ –Ω–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–µ–≥–æ–¥–Ω—è  
                           (status = 'failed' AND completed_at >= $2 AND completed_at <= $3)
                           OR
                           -- –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ —Å –¥–µ–¥–ª–∞–π–Ω–æ–º —Å–µ–≥–æ–¥–Ω—è
                           (status = 'active' AND deadline IS NOT NULL AND deadline >= $2 AND deadline <= $3)
                           OR
                           -- –ó–∞–¥–∞—á–∏ –∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–∞–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–º–∏ —Å–µ–≥–æ–¥–Ω—è (–¥–µ–¥–ª–∞–π–Ω –±—ã–ª –≤—á–µ—Ä–∞)
                           (status = 'overdue' AND deadline IS NOT NULL AND deadline >= $4 AND deadline <= $5)
                       )
                       ORDER BY status, category NULLS LAST""",
                    user_id, today_utc_start, today_utc_end, yesterday_utc_start, yesterday_utc_end
                )

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            review_text = f"üåô –†–µ–≤—å—é –¥–Ω—è {today.strftime('%d.%m.%Y')}\n\n"

            # –ó–∞–ø–∏—Å–∏ –¥–Ω–µ–≤–Ω–∏–∫–∞ —Å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π
            if diary_entries:
                review_text += "üìù –ó–∞–ø–∏—Å–∏ –¥–Ω–µ–≤–Ω–∏–∫–∞:\n"
                for entry in diary_entries:
                    time_str = entry['created_at'].strftime('%H:%M')
                    
                    # –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∑–∞–ø–∏—Å–∏
                    try:
                        decrypted_content = decrypt_text(entry['content'])
                    except Exception as e:
                        logger.error(f"Failed to decrypt diary entry for user {user_id}: {e}")
                        decrypted_content = "[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]"
                    
                    # –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏
                    content = decrypted_content[:150] + ('...' if len(decrypted_content) > 150 else '')
                    review_text += f"‚Ä¢ {time_str} - {content}\n"
                review_text += "\n"
            else:
                review_text += "üìù –ó–∞–ø–∏—Å–µ–π –¥–Ω–µ–≤–Ω–∏–∫–∞ –∑–∞ –¥–µ–Ω—å –Ω–µ—Ç\n\n"

            # –ó–∞–¥–∞—á–∏ –¥–ª—è —Ä–µ–≤—å—é —Å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π
            if review_tasks:
                review_text += "üìã –ó–∞–¥–∞—á–∏:\n"
                
                # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∑–∞–¥–∞—á–∏ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º –∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º
                completed_today = []
                failed_today = []
                active_due_today = []
                overdue_today = []
                
                for task in review_tasks:
                    # –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏
                    try:
                        decrypted_task_text = decrypt_text(task['text'])
                    except Exception as e:
                        logger.error(f"Failed to decrypt task for user {user_id}: {e}")
                        decrypted_task_text = "[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]"
                    
                    task_dict = dict(task)
                    task_dict['text'] = decrypted_task_text
                    
                    if task['status'] == 'completed':
                        completed_today.append(task_dict)
                    elif task['status'] == 'failed':
                        failed_today.append(task_dict)
                    elif task['status'] == 'active':
                        active_due_today.append(task_dict)
                    elif task['status'] == 'overdue':
                        overdue_today.append(task_dict)
                
                if completed_today:
                    review_text += "‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ —Å–µ–≥–æ–¥–Ω—è:\n"
                    for task in completed_today:
                        category_text = f" ({task['category']})" if task['category'] else ""
                        review_text += f"  ‚Ä¢ {task['text']}{category_text}\n"
                    review_text += "\n"
                
                if failed_today:
                    review_text += "‚ùå –û—Ç–º–µ—á–µ–Ω–æ –Ω–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–º–∏ —Å–µ–≥–æ–¥–Ω—è:\n"
                    for task in failed_today:
                        category_text = f" ({task['category']})" if task['category'] else ""
                        review_text += f"  ‚Ä¢ {task['text']}{category_text}\n"
                    review_text += "\n"
                
                if active_due_today:
                    review_text += "üî• –ê–∫—Ç–∏–≤–Ω—ã–µ —Å –¥–µ–¥–ª–∞–π–Ω–æ–º —Å–µ–≥–æ–¥–Ω—è:\n"
                    for task in active_due_today:
                        category_text = f" ({task['category']})" if task['category'] else ""
                        review_text += f"  ‚Ä¢ {task['text']}{category_text}\n"
                    review_text += "\n"
                
                if overdue_today:
                    review_text += "‚ö†Ô∏è –°—Ç–∞–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–º–∏ —Å–µ–≥–æ–¥–Ω—è:\n"
                    for task in overdue_today:
                        category_text = f" ({task['category']})" if task['category'] else ""
                        review_text += f"  ‚Ä¢ {task['text']}{category_text}\n"
                    review_text += "\n"
                
            else:
                review_text += "üìã –†–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –∑–∞–¥–∞—á –∑–∞ –¥–µ–Ω—å –Ω–µ—Ç\n\n"

            review_text += "–•–æ—Ä–æ—à–µ–≥–æ –æ—Ç–¥—ã—Ö–∞! üò¥"

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await self.bot.send_message(user_id, review_text)

        except Exception as e:
            logger.error(f"Error sending evening review to user {user_id}: {e}")

    def _get_day_utc_bounds(self, date, timezone_str):
        """–ü–æ–ª—É—á–∞–µ—Ç UTC –≥—Ä–∞–Ω–∏—Ü—ã –¥–Ω—è –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–π –¥–∞—Ç—ã –≤ —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        import pytz
        from datetime import datetime, time
        
        user_tz = pytz.timezone(timezone_str)
        
        # –ù–∞—á–∞–ª–æ –¥–Ω—è (00:00:00) –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ
        day_start_local = user_tz.localize(datetime.combine(date, time.min))
        # –ö–æ–Ω–µ—Ü –¥–Ω—è (23:59:59) –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ  
        day_end_local = user_tz.localize(datetime.combine(date, time.max))
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ UTC –∏ —É–±–∏—Ä–∞–µ–º timezone info –¥–ª—è –ë–î
        day_start_utc = day_start_local.astimezone(pytz.UTC).replace(tzinfo=None)
        day_end_utc = day_end_local.astimezone(pytz.UTC).replace(tzinfo=None)
        
        return day_start_utc, day_end_utc

    async def check_overdue_tasks(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –ø–æ–º–µ—Ç–∫–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"""
        try:
            # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –ª–∏–º–∏—Ç—ã –∑–∞–¥–∞—á
            TASK_LIMITS = {
                'active': 50,
                'completed': 50,
                'failed': 25,
                'overdue': 25
            }
            
            async with db.pool.acquire() as conn:
                # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∏—Ö —á–∞—Å–æ–≤—ã–º–∏ –ø–æ—è—Å–∞–º–∏
                users = await conn.fetch("SELECT user_id, timezone FROM users")
                
                for user in users:
                    try:
                        from services.timezone_service import get_user_time
                        user_tz = pytz.timezone(user['timezone'])
                        current_time = get_user_time(user['timezone'])
                        current_utc = self._normalize_datetime_for_db(current_time)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ —Å –¥–µ–¥–ª–∞–π–Ω–æ–º
                        overdue_tasks = await conn.fetch(
                            """SELECT task_id FROM tasks 
                               WHERE user_id = $1 AND status = 'active' 
                               AND deadline IS NOT NULL AND deadline < $2""",
                            user['user_id'], current_utc
                        )
                        
                        if overdue_tasks:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
                            overdue_count = await conn.fetchval(
                                "SELECT COUNT(*) FROM tasks WHERE user_id = $1 AND status = 'overdue'",
                                user['user_id']
                            )
                            
                            tasks_to_mark = len(overdue_tasks)
                            
                            # –ï—Å–ª–∏ –ø—Ä–µ–≤—ã—à–∞–µ–º –ª–∏–º–∏—Ç, —É–¥–∞–ª—è–µ–º —Å–∞–º—ã–µ —Å—Ç–∞—Ä—ã–µ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ
                            if overdue_count + tasks_to_mark > TASK_LIMITS['overdue']:
                                delete_count = (overdue_count + tasks_to_mark) - TASK_LIMITS['overdue']
                                await conn.execute(
                                    """DELETE FROM tasks WHERE task_id IN (
                                        SELECT task_id FROM tasks 
                                        WHERE user_id = $1 AND status = 'overdue'
                                        ORDER BY marked_overdue_at ASC LIMIT $2
                                    )""",
                                    user['user_id'], delete_count
                                )
                            
                            # –ü–æ–º–µ—á–∞–µ–º –∑–∞–¥–∞—á–∏ –∫–∞–∫ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ
                            task_ids = [task['task_id'] for task in overdue_tasks]
                            await conn.execute(
                                """UPDATE tasks SET status = 'overdue', marked_overdue_at = NOW() 
                                   WHERE task_id = ANY($1::int[])""",
                                task_ids
                            )
                            
                            logger.info(f"Marked {len(task_ids)} tasks as overdue for user {user['user_id']}")
                    
                    except Exception as e:
                        logger.error(f"Error checking overdue tasks for user {user['user_id']}: {e}")
        
        except Exception as e:
            logger.error(f"Error in check_overdue_tasks: {e}")

    def _normalize_datetime_for_db(self, dt):
        """–ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç datetime –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
        if dt is None:
            return None
        
        # –ï—Å–ª–∏ datetime —Å–æ–¥–µ—Ä–∂–∏—Ç timezone info, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ UTC –∏ —É–±–∏—Ä–∞–µ–º timezone info
        if dt.tzinfo is not None:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ UTC –∏ –¥–µ–ª–∞–µ–º naive
            utc_dt = dt.astimezone(pytz.UTC)
            return utc_dt.replace(tzinfo=None)
        
        # –ï—Å–ª–∏ —É–∂–µ naive, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
        return dt


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
scheduler_service = None


def get_scheduler():
    return scheduler_service


def init_scheduler(bot):
    global scheduler_service
    scheduler_service = SchedulerService(bot)
    return scheduler_service